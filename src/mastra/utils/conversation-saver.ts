import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import type { MBTIType, DiscussionTurn, ComprehensiveQualityReport } from '../types/mbti-types';

/**
 * è­°è«–ä¼šè©±ãƒ‡ãƒ¼ã‚¿
 */
export interface ConversationData {
  topic: string;
  participants: MBTIType[];
  startTime: Date;
  endTime: Date;
  turns: DiscussionTurn[];
  qualityReport: ComprehensiveQualityReport;
  metadata: {
    participantCount: number;
    totalTurns: number;
    enabledFeatures: {
      realtimeOptimization: boolean;
      graphOptimization: boolean;
    };
  };
}

/**
 * å®‰å…¨ãªãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
 */
function sanitizeFileName(input: string): string {
  return input
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 50);
}

/**
 * æ™‚é–“ã‚’èª­ã¿ã‚„ã™ã„å½¢å¼ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
function formatTime(date: Date): string {
  return date.toLocaleString('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
}

/**
 * è­°è«–æ™‚é–“ã‚’è¨ˆç®—
 */
function calculateDuration(start: Date, end: Date): string {
  const diffMs = end.getTime() - start.getTime();
  const diffSec = Math.round(diffMs / 1000);
  const minutes = Math.floor(diffSec / 60);
  const seconds = diffSec % 60;
  return `${minutes}åˆ†${seconds}ç§’`;
}

/**
 * ä¼šè©±ã‚’Markdownå½¢å¼ã§ä¿å­˜
 */
export function saveConversationAsMarkdown(
  data: ConversationData,
  outputDir: string = './conversations'
): string {
  // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
  try {
    mkdirSync(outputDir, { recursive: true });
  } catch (error) {
    console.warn(`Directory creation warning: ${error}`);
  }

  // ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ
  const timestamp = data.startTime.toISOString().slice(0, 19).replace(/[:-]/g, '');
  const topicSafe = sanitizeFileName(data.topic);
  const fileName = `discussion_${timestamp}_${topicSafe}.md`;
  const filePath = join(outputDir, fileName);

  // Markdownã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
  const content = generateMarkdownContent(data);

  // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
  try {
    writeFileSync(filePath, content, 'utf8');
    return filePath;
  } catch (error) {
    throw new Error(`Failed to save conversation: ${error}`);
  }
}

/**
 * Markdownã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
 */
function generateMarkdownContent(data: ConversationData): string {
  const { topic, participants, startTime, endTime, turns, qualityReport, metadata } = data;
  
  return `# MBTI Multi-Agent Discussion Record

## ğŸ“‹ **è­°è«–æ¦‚è¦**

- **ãƒˆãƒ”ãƒƒã‚¯**: ${topic}
- **é–‹å§‹æ™‚åˆ»**: ${formatTime(startTime)}
- **çµ‚äº†æ™‚åˆ»**: ${formatTime(endTime)}
- **è­°è«–æ™‚é–“**: ${calculateDuration(startTime, endTime)}
- **å‚åŠ è€…æ•°**: ${metadata.participantCount}äºº
- **ç·ç™ºè¨€æ•°**: ${metadata.totalTurns}å›

## ğŸ‘¥ **å‚åŠ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**

${participants.map(type => `- **${type}**: ${getAgentDescription(type)}`).join('\n')}

## âš™ï¸ **ã‚·ã‚¹ãƒ†ãƒ è¨­å®š**

- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æœ€é©åŒ–**: ${metadata.enabledFeatures.realtimeOptimization ? 'âœ… ON' : 'âŒ OFF'}
- **ã‚°ãƒ©ãƒ•æœ€é©åŒ–**: ${metadata.enabledFeatures.graphOptimization ? 'âœ… ON' : 'âŒ OFF'}

## ğŸ’¬ **è­°è«–å†…å®¹**

${turns.map((turn, index) => formatTurn(turn, index + 1)).join('\n\n')}

## ğŸ“Š **å“è³ªè©•ä¾¡çµæœ**

### ğŸ† **ç·åˆè©•ä¾¡**: ${qualityReport.overallScore?.toFixed(1)}% (${qualityReport.grade || 'N/A'})

### ğŸ“ˆ **7æ¬¡å…ƒå“è³ªè©•ä¾¡**
${formatQualityMetrics(qualityReport)}

### ğŸ“‹ **è©³ç´°ãƒ¡ãƒˆãƒªã‚¯ã‚¹**
${formatDetailedMetrics(qualityReport)}

### âš¡ **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æœ€é©åŒ–**
- **å®Ÿè¡Œå›æ•°**: ${qualityReport.optimizationResults?.executionCount || 0}å›
- **å“è³ªæ”¹å–„åº¦**: ${qualityReport.optimizationResults?.improvementPercentage?.toFixed(1) || 'N/A'}%

## ğŸ¯ **è­°è«–åˆ†æ**

### ğŸ’ª **å¼·ã¿**
${(qualityReport.strengths || []).map(s => `- ${s}`).join('\n')}

### ğŸ”§ **æ”¹å–„ç‚¹**
${(qualityReport.improvements || []).map(i => `- ${i}`).join('\n')}

---

*Generated by MBTI Multi-Agent Discussion System (M-ADS) Phase 2*  
*Date: ${formatTime(new Date())}*
`;
}

/**
 * ç™ºè¨€ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
function formatTurn(turn: DiscussionTurn, turnNumber: number): string {
  const timestamp = turn.timestamp ? formatTime(new Date(turn.timestamp)) : '';
  const weight = turn.weight !== undefined ? ` (é‡ã¿: ${turn.weight.toFixed(2)})` : '';
  const quality = turn.qualityMetrics ? ` | å“è³ª: ${turn.qualityMetrics.overallQuality?.toFixed(1)}%` : '';
  
  return `### Turn ${turnNumber}: ${turn.agentType}${weight}
*${timestamp}*

${turn.message}
${quality ? `\n*${quality}*` : ''}`;
}

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆèª¬æ˜ã‚’å–å¾—
 */
function getAgentDescription(type: MBTIType): string {
  const descriptions: Record<MBTIType, string> = {
    'INTJ': 'Architect - æˆ¦ç•¥çš„æ€è€ƒå®¶',
    'INTP': 'Thinker - è«–ç†çš„åˆ†æè€…',
    'ENTJ': 'Commander - æŒ‡æ®å®˜å‹ãƒªãƒ¼ãƒ€ãƒ¼',
    'ENTP': 'Debater - è¨è«–è€…ãƒ»ç™ºæ˜å®¶',
    'INFJ': 'Advocate - æå”±è€…ãƒ»ç†æƒ³ä¸»ç¾©è€…',
    'INFP': 'Mediator - ä»²ä»‹è€…ãƒ»ä¾¡å€¤è¦³é‡è¦–',
    'ENFJ': 'Protagonist - ä¸»äººå…¬ãƒ»å”èª¿å‹',
    'ENFP': 'Campaigner - é‹å‹•å®¶ãƒ»æƒ…ç†±å®¶',
    'ISTJ': 'Inspector - ç®¡ç†è€…ãƒ»è²¬ä»»æ„Ÿ',
    'ISFJ': 'Protector - æ“è­·è€…ãƒ»æ€ã„ã‚„ã‚Š',
    'ESTJ': 'Executive - å¹¹éƒ¨ãƒ»åŠ¹ç‡é‡è¦–',
    'ESFJ': 'Consul - é ˜äº‹ãƒ»èª¿å’Œé‡è¦–',
    'ISTP': 'Virtuoso - å·¨åŒ ãƒ»å®Ÿç”¨ä¸»ç¾©',
    'ISFP': 'Adventurer - å†’é™ºå®¶ãƒ»èŠ¸è¡“å®¶',
    'ESTP': 'Entrepreneur - èµ·æ¥­å®¶ãƒ»è¡Œå‹•æ´¾',
    'ESFP': 'Entertainer - ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ†ã‚¤ãƒŠãƒ¼ãƒ»æ¥½å¤©å®¶'
  };
  return descriptions[type] || type;
}

/**
 * å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
function formatQualityMetrics(report: ComprehensiveQualityReport): string {
  const metrics = [
    { name: 'Performance (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹)', value: report.performanceScore },
    { name: 'Psychological (å¿ƒç†çš„é©åˆæ€§)', value: report.psychologicalScore },
    { name: 'External Alignment (å¤–éƒ¨æ•´åˆæ€§)', value: report.externalAlignmentScore },
    { name: 'Internal Consistency (å†…éƒ¨ä¸€è²«æ€§)', value: report.internalConsistencyScore },
    { name: 'Social Decision-making (ç¤¾ä¼šçš„æ„æ€æ±ºå®š)', value: report.socialDecisionScore },
    { name: 'Content Quality (ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å“è³ª)', value: report.contentQualityScore },
    { name: 'Ethics (å€«ç†æ€§)', value: report.ethicsScore }
  ];

  return metrics
    .filter(m => m.value !== undefined)
    .map(m => `- **${m.name}**: ${(m.value! * 100).toFixed(1)}%`)
    .join('\n');
}

/**
 * è©³ç´°ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
function formatDetailedMetrics(report: ComprehensiveQualityReport): string {
  const metrics = [
    { name: 'å¤šæ§˜æ€§ã‚¹ã‚³ã‚¢', value: report.diversityScore },
    { name: 'ä¸€è²«æ€§ã‚¹ã‚³ã‚¢', value: report.consistencyScore },
    { name: 'åæŸåŠ¹ç‡', value: report.convergenceEfficiency },
    { name: 'MBTIæ•´åˆæ€§', value: report.mbtiAlignmentScore },
    { name: 'ç›¸äº’ä½œç”¨å“è³ª', value: report.interactionQuality },
    { name: 'è«–è¨¼å“è³ª', value: report.argumentQuality },
    { name: 'å‚åŠ ãƒãƒ©ãƒ³ã‚¹', value: report.participationBalance },
    { name: 'è§£æ±ºç‡', value: report.resolutionRate }
  ];

  return metrics
    .filter(m => m.value !== undefined)
    .map(m => `- **${m.name}**: ${(m.value! * 100).toFixed(1)}%`)
    .join('\n');
}

/**
 * JSONå½¢å¼ã§ä¼šè©±ã‚’ä¿å­˜
 */
export function saveConversationAsJson(
  data: ConversationData,
  outputDir: string = './conversations'
): string {
  // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
  try {
    mkdirSync(outputDir, { recursive: true });
  } catch (error) {
    console.warn(`Directory creation warning: ${error}`);
  }

  // ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ
  const timestamp = data.startTime.toISOString().slice(0, 19).replace(/[:-]/g, '');
  const topicSafe = sanitizeFileName(data.topic);
  const fileName = `discussion_${timestamp}_${topicSafe}.json`;
  const filePath = join(outputDir, fileName);

  // JSONä¿å­˜
  try {
    const jsonContent = JSON.stringify(data, null, 2);
    writeFileSync(filePath, jsonContent, 'utf8');
    return filePath;
  } catch (error) {
    throw new Error(`Failed to save conversation as JSON: ${error}`);
  }
} 